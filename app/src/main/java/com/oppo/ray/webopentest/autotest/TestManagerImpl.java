package com.oppo.ray.webopentest.autotest;

import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Environment;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import android.util.Log;

import com.google.common.base.Preconditions;
import com.oppo.ray.webopentest.R;
import com.oppo.ray.webopentest.utils.ShellUtils;
import com.oppo.ray.webopentest.utils.Utils;

import java.io.File;
import java.util.List;

public class TestManagerImpl implements ITestManager {
    private static final String TAG = TestManagerImpl.class.getSimpleName();
    private static final boolean DEBUG = false;

    private static final String URLS_PATH = "TestUrl";
    private static final int MSG_TAKE_CAPTURE = 1;
    private static final int MSG_START = 2;
    private static final int MSG_PAUSE = 3;
    private static final int MSG_STOP = 4;
    private static final int MSG_START_TEST = 5;
    private static final int MSG_UPDATE_TIMES = 6;
    private static final int MSG_RESET = 7;
    private static final int MSG_FINISH = 8;

    /**
     * single instance
     */
    private static ITestManager sInstance;
    /**
     * background thread
     */
    private final HandlerThread mHandlerThread;
    /**
     * the urls dir
     */
    private final File mUrlsPath;

    /**
     * the current urls
     */
    private List<String> mCurrentUrls;
    private IProgressCallback mTestCallback;
    /**
     * the config for test
     */
    private TestConfiguration mConfig;
    private int mCurrentTimes = 0;
    /**
     * the current test url
     */
    private String mCurrentTestUrl;
    private int mCurrentTestIndex;

    private final Handler mHandler;
    private final Intent mStartIntent = new Intent();
    private Context mContext;
    private Resources mRes;
    private boolean mIsRunning = false;

    private final Handler.Callback mCallback = new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_TAKE_CAPTURE: {
                    captureInner();
                    return true;
                }
                case MSG_PAUSE: {

                    break;
                }
                case MSG_START: {
                    startInner((TestConfiguration) msg.obj);
                    return true;
                }
                case MSG_STOP: {
                    stopInner();
                    return true;
                }
                case MSG_START_TEST: {
                    testInner();
                    return true;
                }
                case MSG_UPDATE_TIMES: {
                    updateTimes();
                    return true;
                }
                case MSG_RESET: {
                    reset();
                    return true;
                }
                case MSG_FINISH: {
                    onFinish();
                    return true;
                }
            }
            return false;
        }
    };

    private void onFinish() {
        if (null != mTestCallback) {
            mTestCallback.onTestFinish();
        }
    }

    public static ITestManager getInstance() {
        if (null == sInstance) {
            synchronized (TestManagerImpl.class) {
                if (null == sInstance) {
                    sInstance = new TestManagerImpl();
                }
            }
        }
        return sInstance;
    }

    private TestManagerImpl() {
        mHandlerThread = new HandlerThread("BackgroundThread");
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper(), mCallback);
        mUrlsPath = new File("/mnt/sdcard/", URLS_PATH);
        if (!mUrlsPath.isDirectory()) {
            mUrlsPath.mkdirs();
        }
    }

    private void reset() {
        if (null != mCurrentUrls) {
            mCurrentUrls.clear();
        }

        mCurrentTimes = 0;
        mCurrentTestUrl = "";
        mCurrentTestIndex = 0;
    }

    private void updateTimes() {
        int oldTimes = mCurrentTimes;
        this.mCurrentTestIndex = 0;
        if (mIsRunning) {
            this.mCurrentTimes++;
        }
        else {
            this.mCurrentTimes = 0;
            //assign 0 to be hide
            oldTimes = 0;
        }
        if (null != mTestCallback) {
            mTestCallback.onTestTimes(oldTimes, mCurrentTimes);
        }
    }

    private void testInner() {
        //1.first open url use special browser
        startView(mConfig);

        //2.send capture msg
        mHandler.removeMessages(MSG_TAKE_CAPTURE);
        mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_TAKE_CAPTURE), mConfig.getStartDelay());
    }

    private void startView(TestConfiguration configuration) {
        if (!mIsRunning) {
            return;
        }

        this.mCurrentTestUrl = mCurrentUrls.get(mCurrentTestIndex);
        String url = mCurrentTestUrl;
        int time = mCurrentTimes;
        if (DEBUG) {
            String msg = String.format("startView url[%s],time[%d]", url, mCurrentTimes);
            Log.w(TAG, msg);
        }

        if (null != mTestCallback) {
            mTestCallback.onTestUrl(url, time);
        }

        mStartIntent.setPackage(configuration.getCurrentTestPackage());
        mStartIntent.setAction(Intent.ACTION_VIEW);
        mStartIntent.setData(formatUrl(url));
        mStartIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(mStartIntent);

        //update execute time
        mCurrentTestIndex++;
    }

    private Uri formatUrl(String url) {
        if (!"http://".startsWith(url)) {
            return Uri.parse("http://" + url);
        }
        return Uri.parse(url);
    }

    @Override
    public void capture() {
        mHandler.sendEmptyMessageDelayed(MSG_TAKE_CAPTURE, 0);
    }


    private void captureInner() {
        Preconditions.checkArgument(Looper.myLooper() == mHandlerThread.getLooper());
        if (!mIsRunning) {
            return;
        }

        //1.first capture
        File output = Utils.createFile(getUrlConfigDir(), mConfig, mCurrentTestUrl, getCurrentTimes(),
                mCurrentTestIndex, mTestCallback, mContext);
        if (null == output) {
            Log.e(TAG, "create file failed return");
            callError(mRes.getString(R.string.error_create_capture_dir_failed));
            return;
        }

        String absolutePath = output.getAbsolutePath();
        if (DEBUG) {
            Log.e(TAG, String.format("fileAbsPath", absolutePath));
        }

        String fullName = absolutePath;
        String cmd = String.format("/system/bin/screencap -p %s", fullName);
        ShellUtils.execCommand(cmd, true);

        //2.next test
        boolean isLast = mCurrentTestIndex == mCurrentUrls.size();
        boolean isFinished = mCurrentTimes == mConfig.getTimes() && isLast;
        if (isFinished) {
            testFinished();

            if (DEBUG) {
                Log.d(TAG, "captureInner: finished");
            }
        }
        else {
            if (isLast) {
                mHandler.removeMessages(MSG_UPDATE_TIMES);
                mHandler.obtainMessage(MSG_UPDATE_TIMES).sendToTarget();
            }

            //kill the process
            /**
             * QQ浏览器不能一直打开下去
             */
//            Utils.killProcess(mContext, mConfig.getCurrentTestPackage());

            mHandler.removeMessages(MSG_START_TEST);
            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_START_TEST), 200);
        }
    }

    private void testFinished() {
        stopInner();
        mHandler.obtainMessage(MSG_FINISH).sendToTarget();
    }

    private void stopInner() {
        this.mIsRunning = false;
        mHandler.removeMessages(MSG_UPDATE_TIMES);
        mHandler.obtainMessage(MSG_UPDATE_TIMES).sendToTarget();

        mHandler.removeMessages(MSG_TAKE_CAPTURE);
        mHandler.removeMessages(MSG_START);
        mHandler.removeMessages(MSG_PAUSE);
        mHandler.removeMessages(MSG_STOP);
    }

    @Override
    public void setCallback(IProgressCallback callback) {
        this.mTestCallback = callback;
    }

    @Override
    public void pause() {
        mHandler.obtainMessage(MSG_PAUSE).sendToTarget();
        if (null != mTestCallback) {
            mTestCallback.onTestPause();
        }
    }

    @Override
    public void start(TestConfiguration configuration, Context context) {
        this.mContext = context;
        this.mRes = context.getResources();
        mHandler.obtainMessage(MSG_RESET).sendToTarget();
        mHandler.obtainMessage(MSG_START, configuration).sendToTarget();
    }

    private void startInner(TestConfiguration configuration) {
        //1.first parse urls
        this.mConfig = configuration;
        this.mCurrentUrls = Utils.initUrls(mConfig);

        if (null != mTestCallback) {
            mTestCallback.onTestStart();
        }

        if (null == mCurrentUrls || mCurrentUrls.isEmpty()) {
            Log.e(TAG, "start return for urls is null or empty");
            callError(mRes.getString(R.string.error_start_test));
            return;
        }

        //2.start test
        this.mIsRunning = true;
        mHandler.obtainMessage(MSG_UPDATE_TIMES).sendToTarget();
        mHandler.obtainMessage(MSG_START_TEST).sendToTarget();
    }

    @Override
    public void stop() {
        mHandler.obtainMessage(MSG_STOP).sendToTarget();
        if (null != mTestCallback) {
            mTestCallback.onTestStop();
        }
    }

    @Override
    public String getUrlConfigDir() {
        return mUrlsPath.getAbsolutePath();
    }


    public void onDestroy() {
        if (null != mHandlerThread) {
            mHandlerThread.quitSafely();
        }
    }

    @Override
    public int getCurrentTimes() {
        return mCurrentTimes;
    }

    @Override
    public TestConfiguration getCurrentConfig() {
        return mConfig;
    }

    private void callError(String errorMsg) {
        if (null != mTestCallback) {
            mTestCallback.onTestError(errorMsg);
        }
    }

    @Override
    public boolean isRunning() {
        return mIsRunning;
    }
}
