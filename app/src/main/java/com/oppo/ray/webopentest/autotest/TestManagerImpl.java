package com.oppo.ray.webopentest.autotest;

import android.os.Environment;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;

import com.oppo.ray.webopentest.BuildConfig;
import com.oppo.ray.webopentest.utils.ShellUtils;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

/**
 * 需求清单
 * 轮数-----可选择测试轮数
 * Url文件-----可选择apk路径TestUrl下面保存的url文件，可选择要
 * 执行延时----默认选择3s，根据实际情况，可选择1—10s
 * 浏览器----可选择手机上已经按照的浏览器执行，如QQ浏览器、OPPO浏览器等
 * 运行----点击运行，即可自动启动浏览器，依次打开对应URL文件里面的站点
 * 停止----点击停止自动化操作
 * 文件位置----点击可进入TestUrl文件夹目录下面
 * 刷新----有URL文件更换时可操作
 * 日志显示-----显示打开第几个站点，站点的url
 */
public class TestManagerImpl implements ITestManager {
    private static final String TAG = TestManagerImpl.class.getSimpleName();
    private static final boolean DEBUG = BuildConfig.DEBUG;

    private static final String URLS_PATH = "TestUrl";
    private static final String PREFIX = "screenshot_";
    private static final int MSG_TAKE_CAPTURE = 1;

    /**
     * single instance
     */
    private static ITestManager sInstance;
    /**
     * background thread
     */
    private HandlerThread mHandlerThread;
    /**
     * the dir use to save screen shot
     */
    private File mScreenShortDir;
    /**
     * the urls dir
     */
    private File mUrlsPath;

    private String mCurrentTestUrl;
    private IProgressCallback mTestCallback;
    /**
     * the config for test
     */
    private TestConfiguration mConfig;
    /**
     * used to format date
     */
    private SimpleDateFormat mDateFormat;
    private Handler mHandler;
    private Handler.Callback mCallback = new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_TAKE_CAPTURE: {
                    captureInner();
                    return true;
                }
            }
            return false;
        }
    };

    public static ITestManager getInstance() {
        if (null == sInstance) {
            synchronized (TestManagerImpl.class) {
                if (null == sInstance) {
                    sInstance = new TestManagerImpl();
                }
            }
        }
        return sInstance;
    }

    private TestManagerImpl() {
        mHandlerThread = new HandlerThread("BackgroundThread");
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper(), mCallback);
        File file = Environment.getExternalStorageDirectory();
        //TODO check sdcard state
        mUrlsPath = new File(file, URLS_PATH);
        String dir = file.getAbsolutePath() + "/ColorOS/Browser/WebOpenTest/";
        mScreenShortDir = new File(dir);
        if (!mScreenShortDir.isDirectory()) {
            mScreenShortDir.mkdirs();
        }
        mDateFormat = new SimpleDateFormat("yyyy-MM-dd-HH:mm:ss.SSSZ", Locale.getDefault());
    }

    @Override
    public void capture() {
        mHandler.sendEmptyMessageDelayed(MSG_TAKE_CAPTURE, 4000);
    }

    private void captureInner() {
        String fileName = getFileName();
        File output = new File(mScreenShortDir, fileName);
        Log.e(TAG, String.format("mScreenShortDir[%s], fileName=[%s]", mScreenShortDir, fileName));
        if (!output.isFile()) {
            try {
                output.createNewFile();
                String fullName = output.getAbsolutePath();
                String cmd = String.format("/system/bin/screencap -p %s", fullName);
                ShellUtils.execCommand(cmd, true);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private String getFileName() {
        return String.format("%s%s.png", PREFIX, mDateFormat.format(new Date()));
    }

    @Override
    public void setCallback(IProgressCallback callback) {
        this.mTestCallback = callback;
    }

    @Override
    public void pause() {

    }

    @Override
    public void start(TestConfiguration configuration) {

    }

    @Override
    public void stop() {

    }

    public void onDestroy() {
        if (null != mHandlerThread) {
            mHandlerThread.quitSafely();
        }
    }
}
