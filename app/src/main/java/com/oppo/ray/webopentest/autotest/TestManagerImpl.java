package com.oppo.ray.webopentest.autotest;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Environment;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;

import com.google.common.base.Preconditions;
import com.oppo.ray.webopentest.BuildConfig;
import com.oppo.ray.webopentest.utils.ShellUtils;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;

/**
 * 需求清单
 * 轮数-----可选择测试轮数
 * Url文件-----可选择apk路径TestUrl下面保存的url文件，可选择要
 * 执行延时----默认选择3s，根据实际情况，可选择1—10s
 * 浏览器----可选择手机上已经按照的浏览器执行，如QQ浏览器、OPPO浏览器等
 * 运行----点击运行，即可自动启动浏览器，依次打开对应URL文件里面的站点
 * 停止----点击停止自动化操作
 * 文件位置----点击可进入TestUrl文件夹目录下面
 * 刷新----有URL文件更换时可操作
 * 日志显示-----显示打开第几个站点，站点的url
 */
public class TestManagerImpl implements ITestManager {
    private static final String TAG = TestManagerImpl.class.getSimpleName();
    private static final boolean DEBUG = BuildConfig.DEBUG;

    private static final String URLS_PATH = "TestUrl";
    private static final String PREFIX = "screenshot_";
    private static final int MSG_TAKE_CAPTURE = 1;
    private static final int MSG_START = 2;
    private static final int MSG_PAUSE = 3;
    private static final int MSG_STOP = 4;
    private static final int MSG_START_TEST = 5;

    /**
     * single instance
     */
    private static ITestManager sInstance;
    /**
     * background thread
     */
    private HandlerThread mHandlerThread;
    /**
     * the dir use to save screen shot
     */
    private File mScreenShortDir;
    /**
     * the urls dir
     */
    private File mUrlsPath;

    /**
     * the current urls
     */
    private List<ExecuteUrl> mCurrentUrls;
    /**
     * the current test url
     */
    private ExecuteUrl mCurrentTestUrl;

    private IProgressCallback mTestCallback;
    /**
     * the config for test
     */
    private TestConfiguration mConfig;
    /**
     * used to format date
     */
    private SimpleDateFormat mDateFormat;
    private Handler mHandler;
    private Intent mStartIntent = new Intent();
    private Context mContext;
    private Handler.Callback mCallback = new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_TAKE_CAPTURE: {
                    captureInner();
                    return true;
                }
                case MSG_PAUSE: {

                    break;
                }
                case MSG_START: {
                    startInner((TestConfiguration) msg.obj);
                    return true;
                }
                case MSG_STOP: {

                    break;
                }
                case MSG_START_TEST: {
                    testInner();
                }
            }
            return false;
        }
    };

    private void testInner() {
        //1.first open url use special browser
        startView(mConfig);

        //2.send capture msg
        mHandler.removeMessages(MSG_TAKE_CAPTURE);
        mHandler.obtainMessage(MSG_TAKE_CAPTURE, mConfig.getmStartDelay());
    }

    private void startView(TestConfiguration configuration) {
        this.mCurrentTestUrl = mCurrentUrls.get(0);
        int executeTimes = this.mCurrentTestUrl.mEexecuteTimes;
        if (executeTimes >= (configuration.getmTimes() - 1)) {
            this.mCurrentTestUrl = mCurrentUrls.remove(0);
        }
        else {
            //this.mCurrentTestUrl = mCurrentUrls.remove(0);
        }

        String url = mCurrentTestUrl.url;
        int time = mCurrentTestUrl.mEexecuteTimes;
        if (DEBUG) {
            String msg = String.format("startView url[%s],time[%d]", url, time);
            Log.w(TAG, msg);
        }

        if (null != mTestCallback) {
            mTestCallback.onTestUrl(url, time);
        }

        mStartIntent.setPackage(configuration.getmCurrentTestPackage());
        mStartIntent.setAction(Intent.ACTION_VIEW);
        mStartIntent.setData(Uri.parse(url));
        mStartIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(mStartIntent);

        //update execute time
        this.mCurrentTestUrl.mEexecuteTimes++;
    }

    public static ITestManager getInstance() {
        if (null == sInstance) {
            synchronized (TestManagerImpl.class) {
                if (null == sInstance) {
                    sInstance = new TestManagerImpl();
                }
            }
        }
        return sInstance;
    }

    private TestManagerImpl() {
        mHandlerThread = new HandlerThread("BackgroundThread");
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper(), mCallback);
        File file = Environment.getExternalStorageDirectory();
        //TODO check sdcard state
        mUrlsPath = new File(file, URLS_PATH);
        String dir = file.getAbsolutePath() + "/ColorOS/Browser/WebOpenTest/";
        mScreenShortDir = new File(dir);
        if (!mScreenShortDir.isDirectory()) {
            mScreenShortDir.mkdirs();
        }
        mDateFormat = new SimpleDateFormat("yyyy-MM-dd-HH:mm:ss.SSSZ", Locale.getDefault());
    }

    @Override
    public void capture() {
        mHandler.sendEmptyMessageDelayed(MSG_TAKE_CAPTURE, 4000);
    }

    private void captureInner() {
        //1.first capture
        String fileName = getFileName();
        File output = new File(mScreenShortDir, fileName);
        Log.e(TAG, String.format("mScreenShortDir[%s], fileName=[%s]", mScreenShortDir, fileName));
        if (!output.isFile()) {
            try {
                output.createNewFile();
                String fullName = output.getAbsolutePath();
                String cmd = String.format("/system/bin/screencap -p %s", fullName);
                ShellUtils.execCommand(cmd, true);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        //2.next test
        boolean isFinished = mCurrentUrls.isEmpty() && mCurrentTestUrl.mEexecuteTimes == (mConfig.getmTimes() - 1);
        if (isFinished) {
            if (null != mTestCallback) {
                mTestCallback.onFinish();
            }

            if (DEBUG) {
                Log.d(TAG, String.format("captureInner: finished"));
            }
        }
        else {
            mHandler.removeMessages(MSG_START_TEST);
            mHandler.obtainMessage(MSG_START_TEST);
        }
    }

    private String getFileName() {
        return String.format("%s%s.png", PREFIX, mDateFormat.format(new Date()));
    }

    @Override
    public void setCallback(IProgressCallback callback) {
        this.mTestCallback = callback;
    }

    @Override
    public void pause() {

    }

    @Override
    public void start(TestConfiguration configuration, Context context) {
        this.mContext = context;
        mHandler.obtainMessage(MSG_START, configuration).sendToTarget();
    }

    private void startInner(TestConfiguration configuration) {
        //1.first parse urls
        TestConfiguration oldConfig = mConfig;
        this.mConfig = configuration;
        if (null == oldConfig || !oldConfig.isSameConfigFile(configuration)) {
            this.mCurrentUrls = initUrls();
        }
        else {
            if (DEBUG) {
                Log.w(TAG, "same config file");
            }
        }

        if (null == mCurrentUrls || mCurrentUrls.isEmpty()) {
            Log.e(TAG, "start return for urls is null or empty");
            return;
        }

        //2.start test
        mHandler.obtainMessage(MSG_START_TEST).sendToTarget();
    }

    @Override
    public void stop() {

    }

    private List<ExecuteUrl> initUrls() {
        Preconditions.checkArgument(mConfig != null && mConfig.getCurrentUrlFile() != null);
        List<ExecuteUrl> urls = null;

        File currentFile = mConfig.getCurrentUrlFile();
        if (!currentFile.isFile()) {
            Log.e(TAG, "initUrls return for not a file");
            return null;
        }

        BufferedReader reader = null;
        InputStreamReader inputStream = null;
        try {
            inputStream = new InputStreamReader(new FileInputStream(currentFile), "utf-8");
            reader = new BufferedReader(inputStream);
            String line;
            urls = new ArrayList<>();
            while (null != (line = reader.readLine())) {
                urls.add(new ExecuteUrl(0, line));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (null != reader) {
                    reader.close();
                }

                if (null != inputStream) {
                    inputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        if (DEBUG) {
            Log.i(TAG, String.format("initUrls urls[%s]", urls));
        }
        return urls;
    }

    private static class ExecuteUrl {
        private int mEexecuteTimes;
        private String url;

        public ExecuteUrl(int ExecuteTimes, String url) {
            this.mEexecuteTimes = ExecuteTimes;
            this.url = url;
        }
    }

    public void onDestroy() {
        if (null != mHandlerThread) {
            mHandlerThread.quitSafely();
        }
    }
}
